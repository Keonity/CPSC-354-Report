val nil = 
    let val a = new [] in 
    a := "NULL";
    a ;;

val cons = \e. \a. 
    let val b = new [] in
    b := [e,a];
    b ;;

val hd = \a.
    case !a of {
        "NULL" -> "tried to take the head of an empty list",  -- pattern match wtih "NULL", not with nil
        [e,a'] -> e 
    } ;;

val tl = \a.
    case !a of {
        "NULL" -> "tried to take the tail of an empty list",
        [e,a'] -> a'
    } ;;

val length = \a. 
    let val ptr = new [] in
    let val i = new [] in
    i := 0;
    ptr := a;
    while !(!ptr) != "NULL" do
        case !(!ptr) of {
            [e,a'] -> 
                    i := !i + 1; 
                ptr := a'
        } ;
    !i;;

rec lengthRec = \l. 
    case !l of { 
        "NULL" -> 0 , 
        _ -> 1 + length (tail l) 
    } ;;

-- `print (cons 6 (cons 4 (cons 2 nil)))` outputs [6,4,2]
rec print = \list.
    case !list of {
        "NULL" -> [],
        _ -> (hd list):(print (tl list))
    } ;;

--val a = new [];;
--a:=(cons 1(cons 2 nil));;
--val b = 3;;

{-val inbetween = \n. \left. \right.
    let val between = new [] in
    between := [n, right];
    tl(!left) := !between;
    left;;
-}

{-
rec insert = \n. \l. 
    case !l of {
        "NULL" -> l:=(cons n nil),
        _ -> case ((head l) <= n) of {
            False -> insert n (tail l),
            True -> case (head (tail l) > n) of {
                False -> l:=(cons n l),
                True -> l:=(cons n l),
                _ -> (insert n (tail l))
            },
            _ -> insert n (tail l)
        }
    }
    ;;
-}

{-
rec insertA = \n. \l.
    let val ptr = new [] in
    let val i = new [] in
    let val num = new [] in
    i := 0;
    num := n;
    ptr := l;
    while !(!ptr) != "NULL" do
        case !(!ptr) of {
            [e,a'] -> ptr:=a',
            [a'] ->
                    case (!a' < n) of {
                        True -> a':=(cons !a' (cons n l)),
                        False -> insertA n (tail l)
                    }
                ptr:=!a'
        }
    l;;

-}

{-rec insertB = \n. \list.
    let val ptr = new [] in
    let val num = new [] in
    num := n;
    ptr := list;
    case !list of {
        "NULL" -> (cons n nil),
        [e, a'] -> case (e > n) of {
            true -> (cons n nil),
            false -> case ((head a') > n) of {
                True -> (cons e (cons n (tl list))),
                False -> (cons e (insertB n (a')))
            }
        }
--        _ -> case ((head !(!ptr)) > n) of {
--            true -> (cons n list),
--            false -> insertB n n,
--            True -> (cons n list),
--            False -> insertB n !(tail list),
--            _ -> insertB n !(tail list)
--        }
        --while !(!ptr) != "NULL" do
         --   case !(!ptr) of {
           --     [e, a'] -> ptr:=nil,
            --    _ -> ptr:=nil
           -- }
    }
    ;; 
-}

rec insertC = \n. \list.
    --let val ptr = new [] in
    --let val i = new [] in
    --let val newList = new [] in
    --i := 0;
    --ptr := list;
    --newList := n;
    case !list of {
        "NULL" -> (cons n nil),
        [e,a'] -> case ((hd list) >= n) of {
            true -> (cons n list),
            false -> (insertC (e) (insertC n (tl list))),
            _ -> (cons n nil)
        }
    };;

{-
val a = new [];;
val b = new [];;
val c = 3;;
a := [1,nil];;
b := [2,a];;
-}

--print(insertC 3 a);;
{-
-- n = 3, a := [1,nil]
-- case !a of "NULL" = false, [e,a'] = true
-- case ((hd list) >= n) = (1 >= 3) = false (So why does it evaluate as true?) 
-} 

--print (insertB 3 (insertB 2 (insertB 4 (insertB 5 (insertB 1 nil)))));;

rec sort = \l. 
    --let val sortedList = new [] in
    --let val ptr = new [] in
    --ptr:=l;
    --sortedList:=l;
    case !l of {
        "NULL" -> nil,
        [e, a'] -> (insertC e (sort (tl l)))
        --[a'] -> cons a' nil
    };;


-- INSERT
print(insertC 1 (insertC 4 (insertC 2 (insertC 3 nil))));;
print(insertC 1 (insertC 1 (insertC 1 nil)));;
print(insertC 2 (insertC 0 (insertC 25 nil)));;

-- SORT
print (sort (cons 3 (cons 5 (cons 6 (cons 2 nil)))));;
print (sort (cons 221 (cons 0 (cons 1 nil))));;
print (sort (cons 1 (cons 1 (cons 0 (cons 0 (cons 3 nil))))));;