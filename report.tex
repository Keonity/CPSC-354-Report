\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Keoni Lanoza  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Short  summary of purpose and content.  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}

\begin{verbatim}
Name: Keoni Lanoza
Class: Programming Languages
Section: CPSC354-01
Email: lanoza@chapman.edu
\end{verbatim}

This document is a collection of homework assignment answers as requested by Prof. Kurz. This report will replace a generic midterm and final exam and will be thought of as a take home exam to be worked on throughout the semester in addition to a final project.



\section{Homework}\label{homework}

This section will contain your solutions to homework.
For every week, you will have a subsection that contains your answers.

\subsection{Week 1}

\begin{verbatim}
print("Please enter integer A")
aString = input("a: ")
while True:
    try: 
        a = int(aString)
        break
    except ValueError:
        print("Not an integer. Please try again.")
        print("Please enter INTEGER A")
        aString = input("a: ")
    
print("Please enter integer B")
bString = input("b: ")
while True:
    try: 
        b = int(bString)
        break
    except ValueError:
        print("Not an integer. Please try again.")
        print("Please enter INTEGER B")
        bString = input("b: ")

a = int(aString)
b = int(bString)

while (a != b):
    if (a > b):
        a = a - b
    elif (b > a):
        b = b - a
        
print ("The greatest common divisor is: " + str(a))
\end{verbatim}

\indent
This program works by first asking the user to input an integer named "A". 
The program stores this input in a variable called "aString" and then utilizes error checking to make sure the user's input can be converted into an integer.
If the input cannot be converted into an integer, the program loops until the user enters valid input.
If the user's input passes error checking, the program then prompts the user for an integer named "B" and follows the same error-checking process.
Once the user passes error checking for both variables, the program enters a loop.
In the loop, if integer A is greater than integer B, then integer A is replaced with the value of integer A - integer B.
If integer B is greater than integer A, then integer B is replaced with the value of integer B - integer A.
This process repeats until integer A is equal to integer B. When this is reached, the greatest common divisor of the original integer A and original integer B is printed out to the user.

For example, if we took A to be an integer representing the value of 9, and B to be an integer representing the value of 33, the program would follow this process:
Because B, which equals 33 is greater than A, which equals 9. B's value would be replaced with B - A, which is 24. B is still greater than A, so B's value would be replaced by B - A again which now equals 15.
15 is still greater than 9, so B would become 6. Now, A with a value of 9 is greater than B which has a value of 6. A would be replaced with A - B which equals 3. This makes B greater than A again.
B is now replaced with B - A, or 6 - 3, which equals 3. Now that A and B are equal, the greatest common divisor, which is 3 because both A and B equal 3, is output to the user.

\subsection{Week 2}

\begin{verbatim}
import Data.List
import System.IO

select_evens :: [Int] -> [Int]
select_evens (x:xs) = [(x:xs)!!y | y <- (y:ys)] 
  where (y:ys) = [1,3..(length (x:xs)-1)]

select_odds :: [Int] -> [Int]
select_odds (x:xs) = [(x:xs)!!y | y <- (y:ys)] 
  where (y:ys) = [0,2..(length (x:xs)-1)]

member :: Int -> [Int] -> Bool
member _ _ = False
member x (y:ys)
  | x == y = True
  | otherwise = member x ys

append :: [Int] -> [Int] -> [Int]
append (x:xs) (y:ys) = x:xs ++ y:ys

revert :: [Int] -> [Int]
revert [] = []
revert (x:xs) = revert (xs) ++ [x]

less_equal :: [Int] -> [Int] -> Bool
less_equal (x:xs) (y:ys)
  | x >= y = False
  | length (xs) == 0 && length (ys) == 0 = True
  | otherwise = less_equal xs ys

Select_Evens Computation:
select_evens [1,2,3,4,5] =
[] : [(1,2,3,4,5)!!1 | 1 <- ([1,3]) =
2 : [(1,2,3,4,5)!!3 | 3 <- ([1,3]) =
[2, 4]

Select_Odds Computation:
select_odds [1,2,3,4,5] =
[] : [1,2,3,4,5)!!0 | 0 <- ([0,2,4]) =
1 : [(1,2,3,4,5)!!2 | 2 <- ([2,4]) =
1 : (3 : [(1,2,3,4,5)!!4 | 4 <- ([4]) =
[1,3,5] 

Member Computation:
member 1 [3, 2, 1] =
1 == 3 = False, so member 1 [2,1] =
1 == 2 = False, so member 1 [1] =
1 == 1 = True, so 1 is a member of [3, 2, 1]

Append Computation:
append [1,2] [3,4,5] =
1 : (append [2] [3,4,5]) =
1 : (2 : (append [] [3,4,5]) =
1: (2: [3,4,5]) =
[1,2,3,4,5]

Revert Computation:
revert [1,2,3,4,5] =
append (revert [2,3,4,5]) ([1]) =
append (append (revert [3,4,5]) ([2])) ([1]) =
append (append (append (revert [4,5]) ([3])) ([2])) ([1]) =
append (append (append (append (revert [5]) ([4])) ([3])) ([2])) ([1]) =
append (append (append (append (append (revert []) ([5])) ([4])) ([3])) ([2])) ([1]) =
append (append (append (append (append [] ([5])) ([4])) ([3])) ([2])) ([1]) =
append (append (append (append (append [] ([5])) ([4])) ([3])) ([2])) ([1]) =
append (append (append (append ([5]) ([4])) ([3])) ([2])) ([1]) =
append (append (append ([5,4]) ([3])) ([2])) ([1]) =
append (append ([5,4,3]) ([2])) ([1]) =
append ([5,4,3,2]) ([1]) =
[5,4,3,2,1]

Less_Equal Computation:
less_equal [1,2,3] [2,3,4] =
1 >= 2 = False, so less_equal [2,3] [3,4] =
2 >= 3 = False, so less_equal [3] [4] =
3 >= 4 = False, so less_equal [] [] =
True


\end{verbatim}

\subsection{Week 3}

\begin{verbatim}
Tower Of Hanoi correct computations for a tower of 5
hanoi 5 0 2
  hanoi 4 0 1 
    hanoi 3 0 2
      hanoi 2 0 1 
        hanoi 1 0 2 = move 0 2 
        move  0 1
        hanoi 1 2 1 = move 2 1 
      move 0 2  
      hanoi 2 1 2  
        hanoi 1 1 0 = move 1 0  
        move  1 2  
        hanoi 1 0 2 = move 0 2 
    move 0 1
    hanoi 3 2 1
      hanoi 2 2 0
        hanoi 1 2 1 = move 2 1
        move 2 0
        hanoi 1 1 0 = move 1 0
      move 2 1
      hanoi 2 0 1
        hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 1 2 1 = move 2 1
  move 0 2
  hanoi 4 1 2
    hanoi 3 1 0
      hanoi 2 1 2
        hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 1 0 2 = move 0 2
      move 1 0
      hanoi 2 2 0
        hanoi 1 2 1 = move 2 1
        move 2 0
        hanoi 1 1 0 = move 1 0
    move 1 2
    hanoi 3 0 2
      hanoi 2 0 1
        hanoi 1 0 2 = move 0 2
        move 0 1
        hanoi 1 2 1 = move 2 1
      move 0 2
      hanoi 2 1 2
        hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 1 0 2 = move 0 2

\end{verbatim}

Hanoi appears in the computation 31 times.
We can express the number of times "hanoi" appears for any number n of disks with the formula: 

\begin{math}
$$numHanoi =2^{numDisks}-1$$
\end{math}

\subsection{Week 3}
\begin{verbatim}
Concrete Syntax Trees

1. 2+1
           Exp
         /       \
       Exp  +   Exp1
        |        |
      Num        Num
        |          |
        2          1

2. 1+2*3
           Exp
         /       \
       Exp  +   Exp1
        |          |
      Num          Exp1
        |          /   \
        1        Exp1 * Exp2
                   |       |
                 Num      Num
                  |         |
                  2         3 

3. 1+(2*3)
           Exp
         /       \
       Exp  +   Exp2
        |          |
      Num        ( Exp 1 )
        |          /   \
        1        Exp1 * Exp2
                   |       |
                 Num      Num
                  |         |
                  2         3 

4. (1+2)*3
           Exp1
         /       \
       (Exp)  *   Exp2
      /       \      |
    Exp  +  Exp1     Num
      |      |        |
      Num   Num       3
      |       |
      1       2      

5. 1+2*3+4*5+6
                  Exp
               /       \
            Exp    +     Exp1
            /                 \
         Exp                       Exp
        /     \                /         \ 
      Num       Exp1            Exp1        Num 
       |      /      \         /      \       |
       1    Exp1 * Exp2       Exp1 *  Exp2    6
              |       |        |        |
             Num   Num       Num       Num
              |        |        |        |
             2         3       4         5

Abstract Syntax Trees

1. 2+1
        +
      /    \
     2      1

2. 1+2*3
             +
           /   \
          1     *
              /    \
             2      3

3. 1+(2*3) (Same as 2 because parantheses are not in the grammar)
             +
           /   \
          1     *
              /    \
             2      3

4. (1+2)*3 (Same as 2 because parantheses are not in the grammar)
             +
           /   \
          1     *
              /    \
             2      3        

5. 1+2*3+4*5+6
                  +
            /          \
          +             +
       /     \       /      \
     1       *        *      6
           /   \    /  \ 
          2    3    4  5

\end{verbatim}
\ldots

\section{Project}

Introductory remarks ...

The following structure should be suitable for most practical projects. 

\subsection{Specification}
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}

\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\end{document}
